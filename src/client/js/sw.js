/* global caches self URL fetch */
var NOCACHELIST = [
  '/sw.js',
  '/api/',
  '/.+?/.+?/slide',
  '/.+?/.+?.json'
]

var ASSETS = [] // this data is automatically generated by gulp

var CHECKSUM = '' // this data is automatically generated by gulp
var CACHENAME = 'app-assets-' + CHECKSUM

console.log('sw: hello', CHECKSUM)

this.addEventListener('install', function (event) {
  console.log('sw: installed')

  event.waitUntil(
    caches.open(CACHENAME).then(function (cache) {
      return cache.addAll(ASSETS)
    }).then(function () {
      // `skipWaiting()` forces the waiting ServiceWorker to become the
      // active ServiceWorker, triggering the `onactivate` event.
      // Together with `Clients.claim()` this allows a worker to take effect
      // immediately in the client(s).
      console.log('sw: cache all done')
      return self.skipWaiting()
    })
  )
})

self.addEventListener('activate', function (event) {
  console.log('sw: activated')

  return event.waitUntil(
    caches.keys().then(function (keys) {
      return Promise.all(keys.map(function (k) {
        if (k !== CACHENAME && k.indexOf('app-assets-') === 0) {
          console.log('sw: delete cache', k)
          return caches.delete(k)
        } else {
          console.log('sw: keep cache', k)
          return Promise.resolve()
        }
      }))
    }).then(function () {
      // `claim()` sets this worker as the active worker for all clients that
      // match the workers scope and triggers an `oncontrollerchange` event for
      // the clients.
      console.log('sw: claim')
      return self.clients.claim()
    })
  )
})

function shouldUseAppHtml (event) {
  var pathname = new URL(event.request.url).pathname

  var i

  for (i = 0; i < ASSETS.length; ++i) {
    var re = new RegExp('^' + ASSETS[i])
    if (re.test(pathname)) {
      return false
    }
  }

  for (i = 0; i < NOCACHELIST.length; ++i) {
    var re = new RegExp('^' + NOCACHELIST[i])
    if (re.test(pathname)) {
      return false
    }
  }

  if (event.request.method !== 'GET') {
    return false
  }

  var accept = event.request.headers.get('Accept')
  if (!accept || accept.indexOf('text/html') < 0) {
   return false
  }

  return true
}

this.addEventListener('fetch', function (event) {
  event.respondWith(
    // 特定のfetchがあれば、キャッシュをクリアするというのを試してみたい
//    var pathname = new URL(event.request.url).pathname
//    if (pathname = '/clear_cache') {

//    }

    caches.open(CACHENAME).then(function(cache) {
      return cache.match(event.request).then(function (response) {
        if (response) {
          console.log('sw: respond from cache', event.request.url)
          return response
        }

        if (shouldUseAppHtml(event)) {
          return caches.match('/app.html').then(function (response) {
            if (response) {
              console.log('sw: respond app.html', event.request.url)
              return response
            }

            console.log('sw: fetch', event.request.url)
            return fetch(event.request, {credentials: 'include'})
          })
        }

        console.log('sw: fetch', event.request.url)
        return fetch(event.request, {credentials: 'include'})
      })
    })

  )
})


      // TODO: ここから下は、gyazo.com/xxx.pngなどのユーザー画像をキャッシュするかどうか
      // あとで書く
/*

      return fetch(event.request).then(function(response) {
        var shouldCache = false;

        for (var i = 0; i < WHITELIST.length; ++i) {
          var b = new RegExp(WHITELIST[i]);
          if (b.test(event.request.url)) {
//            shouldCache = true;
            break;
          }
        }

        for (var i = 0; i < NOCACHELIST.length; ++i) {
          var b = new RegExp(NOCACHELIST[i]);
          if (b.test(event.request.url)) {
            shouldCache = false;
            break;
          }
        }

        if (event.request.method == 'POST') {
          shouldCache = false;
        }

        if (!response.ok) {
          shouldCache = false;
        }

        if (shouldCache) {
          console.log('sw: save cache', event.request.url)
          return caches.open(CACHENAME).then(function(cache) {
            cache.put(event.request, response.clone());
            return response;
          });
        } else {
          return response;
        }
      });
*/

